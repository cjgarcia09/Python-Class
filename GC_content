### CALUCLATING GC CONTENT ###

### modules ###
import numpy as np
import matplotlib
import pandas as pd
import matplotlib.pyplot as plt
import argparse
from Bio import SeqIO


print ("modules...") # just to make sure modules are entered 

### arguments ###

ap=argparse.ArgumentParser()
ap.add_argument('-i', '--input', required=True, help="name of FASTA file") #FASTA file name 
ap.add_argument("-o", "--output", required=True, help="name of output file")
ap.add_argument('-w', '--window', required=False, nargs="?", default=10000, help="Size of windeow, default=10,000base pairs", type= int)#size of window

args = vars(ap.parse_args())

### Analysing windows ###

def sliding_window_analysis(sequence, function, window_size = args["window"]):
	for start in range (0, len(sequence), window_size):						
		end = start + window_size											
		if end > len(sequence):												
			break															
		yield start, end, function (sequence[start: end])				

### Getting GC content (multiply and divide) ###

def gc_content(sequence):
	num_gc = sequence.count("C") + sequence.count("G")
	div_gc = num_gc/len(sequence)
	return 100 * div_gc
	print ("GC Content:", gc_content(sequence))
	
### Script ###

window_gc = []
windows = 0
for seq_record in SeqIO.parse("efuscus.fsa", "fasta"):
	sequence = seq_record.seq
	#print(seq_record.id, gc_content(sequence))
	for start, end, gc in sliding_window_analysis(sequence, gc_content):
		windows += 1
		print(start, end, gc)
		window_gc.append(gc)
print(window_gc[:5])
print("window count:", windows)	


